// ===============================================================
// WORKER FINAL V6.6 - AUTO DETECT + ANTI RACE CONDITION
// ===============================================================

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);

    // HEADERS CORS
    const corsHeaders = {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type",
    };

    if (request.method === "OPTIONS") {
      return new Response("OK", { headers: corsHeaders });
    }

    // ROUTE 1: CEK SERVER
    if (url.pathname === "/" || url.pathname === "/ping") {
      return new Response("Server Ready (Auto-Detect + Anti-Race)!", { status: 200, headers: corsHeaders });
    }

    // ROUTE 2: AMBIL DAFTAR PRODUK
    if (url.pathname === "/products" && request.method === "GET") {
      try {
        const { results } = await env.db_pembayaran.prepare("SELECT * FROM products").all();
        return jsonResponse(results, 200, corsHeaders);
      } catch (e) {
        return jsonResponse({ error: e.message }, 500, corsHeaders);
      }
    }

    // ROUTE 3: BAYAR (Step 1 - Simpan ke DB & Potong Stok)
    if (url.pathname === "/bayar" && request.method === "POST") {
      return handlePotongStok(request, env, ctx, corsHeaders);
    }

    // ROUTE 4: TOKEN (Step 2 - Request ke Midtrans)
    if (url.pathname === "/api/get-token" && request.method === "POST") {
      return handleGetToken(request, env, corsHeaders);
    }

    // ROUTE 5: NOTIFIKASI (Step 3 - Webhook dari Midtrans - UPDATED)
    if (url.pathname === "/notification" && request.method === "POST") {
      return handleNotification(request, env, corsHeaders);
    }

    // =================================================================
    // ROUTE KHUSUS HARDWARE (ESP32)
    // =================================================================

    // 1. ESP32 CEK ANTRIAN (POLLING)
    if (url.pathname === "/hardware/check" && request.method === "GET") {
       try {
          const queue = await env.db_pembayaran.prepare(`
             SELECT * FROM transactions 
             WHERE status = 'PAID' AND (dispensed = 0 OR dispensed IS NULL)
             ORDER BY created_at ASC 
             LIMIT 1
          `).first();

          if (!queue) {
             return jsonResponse({ available: false }, 200, corsHeaders);
          }

          return jsonResponse({ 
             available: true, 
             order_id: queue.user_token,
             product_id: queue.product_id,
             quantity: queue.quantity 
          }, 200, corsHeaders);

       } catch (e) { return jsonResponse({ error: e.message }, 500, corsHeaders); }
    }

    // 2. ESP32 KONFIRMASI SUKSES (UPDATE DB SETELAH SERVO MUTAR)
    if (url.pathname === "/hardware/confirm" && request.method === "POST") {
       try {
          const body = await request.json();
          const { order_id } = body;

          await env.db_pembayaran.prepare("UPDATE transactions SET dispensed = 1 WHERE user_token = ?")
             .bind(order_id)
             .run();

          return jsonResponse({ success: true }, 200, corsHeaders);
       } catch (e) { return jsonResponse({ error: e.message }, 500, corsHeaders); }
    }

    return new Response("Not Found", { status: 404, headers: corsHeaders });
  }
};

// ---------------------------------------------------------------
// 1. FUNGSI HANDLE POTONG STOK
// ---------------------------------------------------------------
async function handlePotongStok(request, env, ctx, corsHeaders) {
    try {
        const body = await request.json();
        const { user_token, email } = body;
        
        let items = body.items;
        if (!items && body.product_id) {
            items = [{ id: body.product_id, quantity: body.quantity || 1 }];
        }

        if (!items || items.length === 0 || !user_token) {
            return jsonResponse({ error: "Keranjang kosong atau data tidak lengkap" }, 400, corsHeaders);
        }

        const finalEmail = (!email || email.trim() === "") ? "tamu@tokokue.com" : email;
        const createdAt = new Date().toISOString();

        for (const item of items) {
            const product = await env.db_pembayaran.prepare("SELECT * FROM products WHERE id = ?").bind(item.id).first();
            
            if (!product) return jsonResponse({ error: `Produk ID ${item.id} tidak ditemukan` }, 404, corsHeaders);
            if (product.stock < item.quantity) return jsonResponse({ error: `Stok ${product.name} habis!` }, 400, corsHeaders);

            const totalPerItem = product.price * item.quantity;
            const sisaStokBaru = product.stock - item.quantity;

            // Potong Stok
            await env.db_pembayaran.prepare("UPDATE products SET stock = stock - ? WHERE id = ?").bind(item.quantity, item.id).run();

            // Notif Telegram (Background)
            if (sisaStokBaru <= 1) {
                ctx.waitUntil(kirimTelegram(product.name, sisaStokBaru, product.id, env));
            }

            // Insert Transaksi (PENDING)
            await env.db_pembayaran.prepare(`
                INSERT INTO transactions (user_token, product_id, quantity, unit_price, total_price, status, email, created_at) 
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            `).bind(user_token, product.id, item.quantity, product.price, totalPerItem, "PENDING", finalEmail, createdAt).run();
        }

        return jsonResponse({ success: true, message: "Order berhasil disimpan", order_id: user_token }, 200, corsHeaders);

    } catch (e) { return jsonResponse({ error: e.message }, 500, corsHeaders); }
}

// ---------------------------------------------------------------
// 2. FUNGSI HANDLE GET TOKEN (AUTO DETECT SANDBOX/PROD)
// ---------------------------------------------------------------
async function handleGetToken(request, env, corsHeaders) {
    try {
        const serverKey = env.MIDTRANS_SERVER_KEY;
        if (!serverKey) throw new Error("Server Key Missing");

        // üî• DETEKSI OTOMATIS: Apakah ini kunci Sandbox?
        const isSandbox = serverKey.includes("SB-Mid-");
        const midtransUrl = isSandbox 
            ? "https://app.sandbox.midtrans.com/snap/v1/transactions" // Jalur Test
            : "https://app.midtrans.com/snap/v1/transactions";        // Jalur Production

        const body = await request.json();
        
        let itemsInput = body.items;
        if (!itemsInput && body.product_id) itemsInput = [{ id: body.product_id, quantity: body.quantity || 1 }];
        if (!itemsInput || itemsInput.length === 0) throw new Error("Tidak ada barang");

        const orderId = body.order_id || ("TRX-" + Date.now()); 
        const userEmail = body.email || "tamu@tokokue.com";

        let grossAmount = 0;
        let midtransItemDetails = [];

        for (const item of itemsInput) {
            const productDB = await env.db_pembayaran.prepare("SELECT id, price, name FROM products WHERE id = ?").bind(item.id).first();
            if (!productDB) throw new Error(`Produk ID ${item.id} tidak valid`);

            grossAmount += productDB.price * item.quantity;
            midtransItemDetails.push({
                id: productDB.id, price: productDB.price, quantity: item.quantity, name: productDB.name
            });
        }

        const authString = btoa(serverKey + ":");

        // Request ke Midtrans (URL Dinamis)
        const midtransRes = await fetch(midtransUrl, {
            method: "POST",
            headers: { 
                "Accept": "application/json", "Content-Type": "application/json", 
                "Authorization": "Basic " + authString 
            },
            body: JSON.stringify({
                transaction_details: { order_id: orderId, gross_amount: grossAmount },
                item_details: midtransItemDetails,
                customer_details: { first_name: "Pelanggan", email: userEmail }
            })
        });

        const midtransData = await midtransRes.json();
        return jsonResponse(midtransData, midtransRes.status, corsHeaders);

    } catch (e) { return jsonResponse({ error: e.message }, 500, corsHeaders); }
}

// ---------------------------------------------------------------
// 3. FUNGSI NOTIFIKASI (WEBHOOK) - üî• DENGAN ANTI-RACE CONDITION
// ---------------------------------------------------------------
async function handleNotification(request, env, corsHeaders) {
  try {
    const data = await request.json();
    console.log("üî• [WEBHOOK MASUK]:", JSON.stringify(data)); 

    const orderId = String(data.order_id).trim();
    const transactionStatus = String(data.transaction_status).toLowerCase();
    const fraudStatus = data.fraud_status ? String(data.fraud_status).toLowerCase() : "";

    let statusDb = "PENDING"; 

    if (transactionStatus === 'capture') {
      if (fraudStatus === 'challenge') statusDb = 'CHALLENGE';
      else if (fraudStatus === 'accept') statusDb = 'PAID';
    } else if (transactionStatus === 'settlement') {
      statusDb = 'PAID'; 
    } else if (['cancel', 'deny', 'expire', 'failure'].includes(transactionStatus)) {
      statusDb = 'FAILED';
    }

    // --- LOGIKA ANTI BALAPAN (RETRY MECHANISM) ---
    // Cek apakah data sudah ada?
    let transaction = await env.db_pembayaran.prepare("SELECT * FROM transactions WHERE user_token = ?").bind(orderId).first();

    // Jika data belum ada (Frontend lambat), tunggu 2 detik lalu cek lagi (Maksimal 3x)
    // 
    if (!transaction && statusDb === 'PAID') {
        console.log(`‚ö†Ô∏è Data ${orderId} belum ada, menunggu frontend...`);
        
        for (let i = 0; i < 3; i++) {
            await new Promise(r => setTimeout(r, 2000)); // Tunggu 2 detik
            transaction = await env.db_pembayaran.prepare("SELECT * FROM transactions WHERE user_token = ?").bind(orderId).first();
            if (transaction) break; // Kalau sudah muncul, lanjut update!
        }
    }
    // ---------------------------------------------

    if (statusDb === 'PAID') {
        // Gunakan logic UPDATE yang memastikan baris ter-update
        const result = await env.db_pembayaran.prepare("UPDATE transactions SET status = 'PAID' WHERE user_token = ?").bind(orderId).run();
        console.log(`‚úÖ Update PAID untuk ${orderId}. Rows affected: ${result.meta.changes}`);
    } else {
        await env.db_pembayaran.prepare("UPDATE transactions SET status = ? WHERE user_token = ?").bind(statusDb, orderId).run();
    }

    return new Response("OK", { status: 200, headers: corsHeaders });

  } catch (error) {
    console.error("‚ùå WEBHOOK ERROR:", error.message);
    return new Response("OK", { status: 200, headers: corsHeaders });
  }
}

function jsonResponse(data, status, headers) {
    return new Response(JSON.stringify(data), { status, headers: { ...headers, "Content-Type": "application/json" } });
}

// ---------------------------------------------------------------
// 4. TELEGRAM NOTIF
// ---------------------------------------------------------------
async function kirimTelegram(namaProduk, sisaStok, slotID, env) {
  const BOT_TOKEN = env.TELEGRAM_BOT_TOKEN;
  const CHAT_ID = env.TELEGRAM_CHAT_ID; 

  if (!BOT_TOKEN || !CHAT_ID) return;

  const pesan = `üö® *STOK KRITIS*\nüì¶: *${namaProduk}*\nüìç: *${slotID}*\n‚ö†Ô∏è Sisa: *${sisaStok}*`;
  const url = `https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`;

  try {
    await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ chat_id: CHAT_ID, text: pesan, parse_mode: 'Markdown' })
    });
  } catch (e) { console.log("Telegram Error:", e); }
}
